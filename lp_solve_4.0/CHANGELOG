Changed after first review for comp.sources.reviewed:

- Bug with row singletons and assignment fixed.
- Makefile fixed.
- Formatted man page (lp_solve.man) added + target to generate it in the
  Makefile
- install signal handler after reading the input to avoid dumping core
- changed names of some examples to make them uniform
- added correct results for all examples

Changes since the comp.sources.reviewed release:

- added more input sanity checking
- removed a bug in the Branch-and-Bound code which could cause umlimited
  recursion and finally a core dump
- removed the duplicate declaration of global variable Rows
- replaced bcopy by the ANSI standard memcopy
- various small cosmetic changes

Changes for version 1.1

- added KNOWN_BUGS file.
- accept x <= 0 as a sane bound.

Changes for version 1.2

- added (unsupported by me) VMS_SUPPORT file
- made lp_solve print the reason a problem cannot be solved (unbounded or
  infeasible)
- added input format extension to optionally indicate whether the objective
  function should be minimized or maximized.
- Added output(!) in real MPS format for the -v option.

Changes for version 1.3

- Added #ifdefs to handle the different definitions necessary for yytext on
  different computers. Why is there no standard???
- Fixed a very nasty bug in the parser which would handle variables on the
  right hand side of the relational operator which had an effective negative
  sign wrongly (actually, the negative sign was ignored).
- added -p option to print the values of the dual variables.
- Added test target in Makefile to allow automatic testing with the standard
  examples ex[1-5].lp.
- Added syntax extension for optional user specified constraint (dual) names.
- Fixed bug in the combination of minimization of the objective function
  (min: <obj fun>) and MILP problems. Pure LP worked ok.
- From now on lp_solve refuses problems with just bounds (0 real constraints).
  This does not work anyway.

Changes for version 1.4

- Various cosmetic changes to the sources
- Added ex6.lp just for fun (read it!).
- Added results obtained on netlib and miplib benchmark sets (thanks to
  mps2eq).
- removed pragmas for Alliant computers (they're out of business anyway).
- changed the default "double" type to REAL, which can be changed during
  compilation (-DREAL=float or -DREAL='long double')

Changes for version 1.5

- Added -scale option for global scaling of the problem.
- Fixed problem with Endetacol being written out of bounds.
- Added -autoscale option for automatic scaling of rows and columns.
- Added ex7.lp, an example which can only be solved when scaled properly.
- Added -solve_dual option to let lp_solve solve the dual of the problem it is
  reading. This is not a very useful option, but I needed it to check the
  results generated by the updated -p option (see next item). It will not work
  with equality constraints.
- The -p option now produces real dual values, thanks to a code hint by
  Jeroen Dirks (jeroend@tor.numetrix.com)
- The MILP branch-and-bound loop was rearranged by Jeroen Dirks resulting in
  significantly increased performance (2 - 10 times faster).


Changes for 2.0a

- Added a procedural interface (the lp toolkit).
- removed -scale and -solve_dual options
- renamed option -autoscale to -s

Changes for 2.0b1

- Added -mps option to read MPS files. And also included some mps associated
  functions in the toolkit.

Changes for 2.0b2

- Fixed bug in:
	delete_lp
	del_constraint
	write_MPS
- added:
	write_LP
	msp2lp
	lp2mps

Changes for 2.0b3

- Changed default integer/noninteger value to 1e-3
- Added Epsb in Iteration function at minit detection
  (lp_solve gave infeasible for some feasible problems)
- Added -degen perturbation option for degenerate problems.

Changes for 2.0

- Removed "Parsing" message
- Made CHECK Warning output print to stderr

Changes for 2.1beta

- added '-time' option to print CPU times of parsing and optimization
- fixed some MPS reading problems
- allow empty OF in lp_solve format to get just a feasible solution
- added filtering of very small pivots to improve numerical stability
- fixed several bugs in lpkit.c and readmps.c

Changes for 2.1

- improved the speed of the MPS reader (considerably!) by introducing hash
  tables
- fixed bug in column_in_lp
- updated Jeroen Dirks' email address in the sources
- added HARTMUT_DOCUMENTATION to the distribution

Changes for 2.2

- fixed memory leak in delete_lp
- fixed some more lpkit.c bugs
- got rid of the ugly global variables used in solve.c.

Changes for 2.3

- fixed memory problem in solve.c (eta arrays were not always realloc-ed on
  time).
- support for RANGES in MPS reworked; should now be according to standard
- option -degen could sometimes produce "results" for infeasible problems,
  fixed.
- previous versions of lp_solve would not scale any column when integer
  variables were present. Now only the actual integer columns are not scaled.
- copy_lp now also copies the rowname and colname hash tables

Changes for 3.0

- lp_solve now has an official open source license, 3.0 and up will have the
  LGPL license attached.
- there was a problem in write_MPS, where numbers were printed with up to 16
  digits instead of the maximum of 12

Changes for 3.0

- Bug fix with -degen option (constants were not so constant any more)

Changes for 3.1

- copy name strings in copy_hash_table to avoid crashes when old lp's are freed
- added call to btran at line 925 of solve.c according to an analysis by Joerg
  Herbers

Changes for 3.1a

- fixed memory management problem in read.c introduced in 3.1

Changes for 3.2

- fixed eta realloc problem in solve.c

Changes for 4.0.0.0

- Added files fortify.c, fortify.h, ufortify.h, declare.h
  fortify is a memory management wrapper. It redirects all memory management
  routines like malloc, calloc, realloc, free, ... to own routines. The purpose
  of this is purely for debugging. This 'library' adds leading and trailing
  bytes to each allocated piece of memory which makes it possible to check if
  no memory before or after the allocated block was written. Although this is
  not a perfect method of finding memory overruns, it is a big help in finding
  95% of them. It also checks if all allocated memory is freeed again between a
  given starting and ending point. This 'library' has helped me already
  numerious times to easilly find and pinpoint these problems on the place and
  on the variable where the problem occurs and not on totally different one
  which is very common to this kind of problems.
  Use of this library is very easily.
   - Just include fortify.h in the source file(s) where memory allocation
     functions are used.
   - Define the constant FORTIFY

- Corrected some spelling in different source files.

- Removed exit functions.
  This change is needed when lp_solve is used as a library which is called
  from an application.
  Terminating the process is sertainly not a good idea in that case. When a
  severe error occurs, the called function will return exit false to indicate
  that a problem occured and lp->spx_status indicates what the problem is.

- Modified the MALLOC, CALLOC, REALLOC functions to not exit the program if no
  memory could be allocated. Instead the calling functions exit with a return
  code FALSE to indicate there was a problem. The cller program then has to
  check lp->spx_status to see what the problem is. If out of memory then its
  value is the constant OUT_OF_MEMORY.

- The lprec structure has changed considerably. This means that programs must
  be recompiled when they link with this new library.
  A couble of members are deleted, some have changed and several new members
  are created. Be aware of this.
  However the interface to the library is kept as much as possible, so
  recompilation should be possible without modification. One thing is to be
  considered however. Several routines that previously returned a void now
  return int to indicate if they succeeded. They can fail if there is not
  enough memory available. The return status should always be checked ...

- The lpkit.h include file defines some constants like
  DEF_INFINITE, DEF_EPSB, DEF_EPSEL, DEF_EPSD, DEF_EPSILON, PREJ, ...
  It is now possible to overrule these defaults at compile time by defining them
  at that time (generally via the -D compiler option).

- Some constants like DEF_EPSB, DEF_EPSD, DEF_EPSILON
  have now better default values.
  For example in the past, DEF_EPSILON was set to 0.001. This value is the
  tolerance to determine if a REAL is integer. This is used for integer
  optimization. 0.0005 was in the past accepted as an integer value.
  This is now changed to 1e-6

- mps2lp and lp2mps now accept optionally input and output files via the
  command line. It is still possible to work via stdin and stdout (redirection)
    Usage:
      mps2lp [inputfile.mps [outputfile.lp]] [<inputfile.mps] [>outputfile.lp]
      lp2mps [inputfile.lp [outputfile.mps]] [<inputfile.lp] [>outputfile.mps]
- mps2lp and lp2mps now return meaningfull exit codes
   0: File converted successfully
   1: Usage screen was shown
   2: Unable to open input file
   3: Unable to open output file
   4: Unable to read mps/lp file
   5: Unable to write lp/mps file

- Rearranged include header files in hash.c, read.c, lpkit.c
  First the standard C headers are included and then own project headers.
  Some compilers gave warning otherwise.

- Until version 3 there was no presolve implemented in lp_solve. From this
  version there is. The routine is implemented in presolve.c
  By default lp_solve does not do a presolve.
  Member do_presolve of the lprec structure must be set on TRUE before the
  solve() routine is called to do a presolve.
  Presolve can do the following operations:
   - remove empty rows
   - remove empty columns
   - convert rows with only 1 coefficient on a variable to a bound
  A presolve can make the lp problem smaller so that solution time is shorter.

- Debugging/tracing routines in debug.c were always printing results to stderr.
  There is now a new routine print_file() to make the output go to a file.
  Default the output still goes to stderr. If the provided filename is NULL,
  then output is set (back) to stderr.
  The return value of this routine is TRUE or FALSE indicating if file could
  be created (TRUE) of not (FALSE).
  Some debugging routines were moved from lpkit.c to debug.c:
   print_lp()
   print_solution()

- Routine print_solution() is split in several routines:
   print_objective()
   print_solution()
   print_constraints()
   print_duals()
   print_scales()

- A new routine report is added in debug.c to report messages. These messages
  are mostly debugging and tracing messages shown in verbose mode.
  In fact this routine is a replacement for an already existing routine
  error() which always printed to stderr.
  Until version 3 these messages were always reported to stderr or stdout.
  Default this routine reports to stderr, but via a new member in the lprec
  structure (writelog), it is now possible to define an own reporting routine.
  How much the routine will report depends on the verbose level. Until
  version 3 there were only two possible values for the verbose member in the
  lprec structure: TRUE or FALSE: report or not. From version 4 there are seven
  possible verbose levels. They are defined via constants:

    #define CRITICALSTOP    0
    #define CRITICAL        1
    #define SEVERE          2
    #define IMPORTANT       3
    #define NORMAL          4
    #define DETAILED        5
    #define FULL            6

  The bigger the number, the more reporting. 0 is as good as no reporting.
  This will only occur when a severe error occurs. It is the default verbose
  level. It is only generated by the lp parse routine and will raise a
  termination signal SIGABRT if it occurs.
  FULL is report everything.
  The lp_solve executable supports these different levels via an extra number
  to be added with the -v option. For example -v4 indicates verbose level 4.
  When only -v is specified, thus with a number, then verbose level NORMAL (4)
  is used.

- Row and column names can be provided. This is indicated by the member
  names_used op the lprec structure. Until version 3 one had to check this
  value to know if lp->col_name and lp->row_name could be accessed to get this
  name and if now one was constructed either as Row[x] or r_x
  From version 4 it is better to use the new routines get_col_name() and
  get_row_name() to get a name. It may always be called, even if no names
  were provided. In that case a name r_x or v_x is generated.
  That way names are always consequent, which was not the case until version 3.

- Reading and writing lp model. Now supports also ranges. This means that a
  minimum and maximum on a row can be one line. This was already supported by
  the MPS format, but not in the lp format. Not only this gives this the
  advantage that a row doesn't have to be repeated with the same coefficients
  and only a different restriction, but more important the algorithm will
  perform better when this is done. Less memory is needed and a solution
  will be found faster.

- Added a routine read_LP to read an lp file. This is identical to
  read_lp_file, except that read_LP accepts a file name while read_lp_file
  needs a file pointer to an already opened file.

- read_lp_file now uses a common routine to allocate the lp structures instead
  of building it by itself. This makes it easier to modify the lp structures.

- Reading MPS files gave sometimes a parsing error when extra spaces were at
  the end of a line.

- Added a routine read_MPS to read an MPS file. This is identical to
  read_mps, except that read_MPS accepts a file name while read_mps
  needs a file pointer to an already opened file.

- Some memory leaks could occur in several surcomstances.

- Added a new routine set_bounds() to specify lower and upper bound of a
  variable at once. Routines set_upbo() and set_lowbo() still exists.

- Added semi-continious optimization. The MPS BOUNDS section now support types
  SC and SI and a new routine is added to specify a variable as semi-continious
  set_semicont(). Routine is_semicont() returns TRUE if column is set as semi-continious.
  SC stands for Semi Continious and SI for Semi-continius Integer.
  The lp-format doesn't know the SC and SI restrictions.

- Added SOS optimization. A new routine is added to specify a variable as SOS:
  add_SOS(). Routine is_SOS_var() returns TRUE if column is set as SOS.
  In the MPS files SOS restrictions can be specified in the SOS section.
  The lp-format doesn't know the SOS restrictions.
  See SOSInterpolation.pdf for a description about SOS optimization.

- Variables of type FR (free variables ie between minus infinity and plus
  infinity were split in two variables. This isn't the case anymore.

- Added max_allowed_columns and set_magic(). Purpose ???

- Added a new routine lp_solve_version() to get the version number of lp_solve
  The version number is still kept in patchlevel.h, however no longer as a
  string, but as 4 numbers:
   #define MAJORVERSION    4
   #define MINORVERSION    0
   #define RELEASE         0
   #define BUILD           0
  This new routine returns those 4 values.

- Added new routine is_int which returns TRUE if column variable is integer.

- Added a new routine make_lpext() which allows to create a new lprec structure
  like make_lp does, but with more parameters so that it can also be used by
  the lp parser. make_lp calles this routine also. By doing this all code to
  create the lprec structure is in only one routine. Is ment for internal use.

- Scaling routine is improved considerably. Some bug were fixed.
  Also added scaling to lagrange variables.
  The new member scalemode in the lprec structure specifies what kind of
  scaling must be done.
  This can be:
    - MMSCALING:  Do numerical range-based scaling (default, original)
    - GEOSCALING: Do geometric mean scaling
    - POWERSCALE: create a scalar of power 2, if specified; may improve compute
    - CURTISREIDSCALE: Do Curtis-Reid scaling.
    - LAGRANGESCALE: Also scale Lagrange columns. Default they are not scaled.
    - INTEGERSCALE: Also scale Integer columns. Default they are not scaled.

  Either MMSCALING or GEOSCALING or CURTISREIDSCALE may be chosen.
  MMSCALING and GEOSCALING can be combined with POWERSCALE by ORing this value
  These values may be ORed to combine several scaling methods
  The default is MMSCALING scaling.
  For Curtis-Reid scaling the routine scaleCR must be called instead of (auto_)scale.

- Added two new routines for getting the unscaled lower and upper bounds
  on variables:
    get_upbo()
    get_lowbo()

- Added routines set_uprange() and set_lowrange() to specify upper and lower
  ranges. Scaling is applied in the routines.

- Added routine get_rh() to retrieve unscaled RHS value.

- Added routine set_rh_range() to set a range on RHS value and get_rh_range()
  to retrieve the unscaled value.

- Added routine get_constr_type() to get contraint type.

- Added routine get_mat() as an alternative for mat_elm()

- Bug corrections in routine get_reduced_costs(). Did not work correct if
  scaling was used. This routine also returns the same as lp->duals.

- get_reduced_costs() and lp->duals now return also the reduced costs of the
  variables. It now returns an array of 1 + rows + columns elements.

- get_reduced_costs() returned wrong values if integer variables were used.

- Added routines calculate_sensitivity_duals, setpivrow,
  calculate_sensitivity_obj to calculated sensitivity analysis on reduced costs
  (lp->dualsfrom, lp->dualsto) and on objective function
  (lp->objfrom, lp->objto)
  This to provide post-optimal sensitivity analysis on the model.

- Added members objfrom, objtill to lprec structure. These contain the
  from-till ranges of the object coefficients where the variables keep their
  values. This is part of post-optimal sensitivity analaysis.

- Added new routine set_lp_name() to set the name of the lp problem.
  Should be used instead of manipulating lp->lp_name

- Added a test to unscale_columns() if columns are already unscaled that
  nothing happens.

- Added routine set_basis() to set an inititial base and get_basis() to get the
  base variables.

- Added printing of ranges in write_LP()

- Added routine write_lp(). This routines does the same as write_LP, but allows
  to specify the filename directly.

- Corrected write_MPS() routine to make sure that column and row labels aren't
  printed outside of MPS field bounds (name max 8 characters). Longer names are
  truncated. This could result in duplicate names, so be careful if this
  happens.

- Corrected write_MPS() routine to print only a BOUNDS section when at least
  one bound exists.

- Added routine write_mps(). This routines does the same as write_MPS, but
  allows to specify the filename directly.

- Added the new field sectimeout in lprec structure to specify a timeout. When
  solving takes longer than this timeout, the solver stops with a TIMEOUT
  return value.

- Added the new field abort in lprec structure to specify an abort routine
  which is regularly called to check if the user didn't abort. This can be set
  via the new routine put_abortfunc()

- Added the new field usermessage in lprec structure to specify a message
  routine which will be called by lp_solve so that the user can receive some
  messages from the algothm what it is doing. This can be set via the new
  put_msgfunc() routine.
  The following constants in lpkit.h can be used to specify what can be reported
    #define MSG_NONE             0
    #define MSG_PRESOLVE         1
    #define MSG_ITERATION        2
    #define MSG_INVERT           4
    #define MSG_LPFEASIBLE       8
    #define MSG_LPEQUAL         16
    #define MSG_LPBETTER        32
    #define MSG_MILPFEASIBLE    64
    #define MSG_MILPEQUAL      128
    #define MSG_MILPBETTER     256
    #define MSG_MILPSTRATEGY   512

- Added some double precision calculations on critical points to improve
  numerical stability.

- Improved branch-and-bound integer algorithm.

- Improved lagrange solver.

- Added several other improvements to the algorithm.

- Extended check_solution routine to check if found solution is valid. This
  is only used for debugging purposes and only called when CHECK_SOLUTION is
  defined at compile time. Default it is not defined.

- Extended floor_first member of lprec structure with a value AUTOMATIC (2)
  Used for integer optimization in branch-and-bound algorithm.
   - When set to FALSE (0), the algorithm will always choose the floor branch
     first.
   - When set to TRUE (1), the algorithm will always choose the ceiling branch
     first.
   - When set to AUTOMATIC (2), the algorithm will deside what branch to take
     first. This could lead to a faster solution time.
  The lp_solve executable supports this via the -c and -ca command line options.

- Added a new member improve to the lprec structure.
  This is used internally by the algorithm for iterative improvement.
  The possible values can be:
    IMPROVE_NONE    0
    IMPROVE_FTRAN   1
    IMPROVE_BTRAN   2
    IMPROVE_FULL    (IMPROVE_FTRAN + IMPROVE_BTRAN);

  IMPROVE_NONE is the default.

- Extended bb_rule in lprec structure.
  The possible constants are now:
    FIRST_SELECT  0: Lowest indexed non-integer column
    RAND_SELECT   1: Random non-integer column
    WORST_SELECT  2: Largest deviation from an integer value
    BEST_SELECT   3: ???
    MEDIAN_SELECT 4: Median value deviation from an integer value
    GREEDY_SELECT 5: ???

  The constants FIRST_NI and RAND_NI are still defined for backward
  compatibility.

- Extended solve exit codes:

    #define UNKNOWN        -5
    #define NOTRUN         -4
    #define USERABORT      -3
    #define TIMEOUT        -2
    #define IGNORED        -1
    #define OPTIMAL         0
    #define MILP_FAIL       1
    #define INFEASIBLE      2
    #define UNBOUNDED       3
    #define FAILURE         4
    #define RUNNING         5

    /* lag_solve extra status values */
    #define FEAS_FOUND      6
    #define NO_FEAS_FOUND   7
    #define BREAK_BB        8

- The lp_solve command line program is modified to handle the new functionality
  of version 4 and there are also some bug fixes. Following thing have changed:
   - If a file name was provided to the command line then it was ignored when
     data is read from an lp-file (-mps option not provied). Input was still
     read from stdin instead. This is now solved.
   - -min and -max options were accepted, but ignored. Corrected.
   - Option -v is extended with a number to specify a verbose level.
     See description above of verbose member in lprec structure for possible
     values. For example -v4 indicates verbose level 4.
     When only -v is specified, thus with a number, then verbose level
     NORMAL (4) is used. If the option is not provided, then SEVERE (2) is used.
   - A new option -lp is added to indicate that the input file is lp. This is
     the default if neither -lp or -mps is specified.
   - A new option -presolve is added to enable presolving.
   - A new option -S is added to specify how much of the solution must be
     outputed. This option has an optional number:
       -S0: Print nothing
       -S1: Only objective value
       -S2: Objective value + variables (default)
       -S3: Objective value + variables + constraints
       -S4: Objective value + variables + constraints + duals
       -S5: Objective value + variables + constraints + duals + lp model
       -S6: Objective value + variables + constraints + duals + lp model + lp scales
     If only -S is specified then -S2 is used.
     Until version 3 this was controled with the -v option. It was an al or
     nothing flag which also resulted in printing details of the algorithm.
     This new option allows to specify more detailed what is wanted.
   - Option -trej
   - option -improve to specify an iterative improvement level.
   - Option -ca: sets lp->floor_first to automatic
   - Option -s is extended with an optional mode
      -s0: Numerical range-based scaling (default)
      -s1: Geometric scaling
      -s2: Curtis-reid scaling
   - New option -sp
     This option only makes sense if -s option was used. It specifies that
     scales must be power of two. Can improve numerical stability.
   - New option -sl
     enables Lagragrange scaling.
   - New option -si
     enables Integer scaling.

- Following is a list of new functions which can be called:

   void lp_solve_version(int *majorversion, int *minorversion, int *release, int *build);

   void set_magic(int code, int param);

   lprec *read_LP(char *input, short verbose, char *lp_name);

   void set_uprange(lprec *lp, int row, REAL value);

   void set_lowrange(lprec *lp, int row, REAL value);

   short is_int(lprec *lp, int column);

   void set_semicont(lprec *lp, int column, short must_be_sc);

   short is_semicont(lprec *lp, int column);

   int add_SOS(lprec *lp, char *name, short sostype, int priority, int count, int *sosvars, REAL *weights);

   short is_SOS_var(lprec *lp, int column);

   int set_lp_name(lprec *lp, char *name);

   REAL get_rh(lprec *lp, int row);

   void set_rh_range(lprec *lp, int row, REAL deltavalue);

   REAL get_rh_range(lprec *lp, int row);

   short get_constr_type(lprec *lp, int row);

   char *get_row_name(lprec *lp, int row);

   char *get_col_name(lprec *lp, int column);

   REAL scale(lprec *lp, REAL *myrowscale, REAL *mycolscale);

   int scaleCR(lprec *lp);

   void set_basis(lprec *lp, int *bascolumn);

   void get_basis(lprec *lp, int *bascolumn);

   lprec *read_MPS(char *input, short verbose);

   int write_mps(lprec *lp, char *output);

   int write_lp(lprec *lp, char *output);

   void print_objective(lprec *lp);

   void print_constraints(lprec *lp);

   int print_file(char *filename);


- Following functions now return a status if they succeeded or not. The
  returnvalue should always be checked. TRUE is ok, FALSE is not ok

   int set_mat(lprec *lp, int row, int column, REAL value);

   int set_obj_fn(lprec *lp, REAL *row);

   int str_set_obj_fn(lprec *lp, char *row);

   int add_constraint(lprec *lp, REAL *row, short constr_type, REAL rh);

   int str_add_constraint(lprec *lp, char *row_string ,short constr_type,
                          REAL rh);

   int add_lag_con(lprec *lp, REAL *row, short con_type, REAL rhs);

   int str_add_lag_con(lprec *lp, char *row, short con_type, REAL rhs);

   int add_column(lprec *lp, REAL *column);

   int str_add_column(lprec *lp, char *col_string);

   int str_set_rh_vec(lprec *lp, char *rh_string);

   int set_col_name(lprec *lp, int column, char *new_name);

   int write_MPS(lprec *lp, FILE *output);

   int write_LP(lprec *lp, FILE *output);

- write_MPS, write_mps is enhanced. The COLUMNS, RHS, RANGES sections now also use
  columns 40-47 and 50-61 to write the data. This results in smaller MPS files.
  The routines also write SOS and SC data.

Changes for 4.0.1.0

- Added in each header file (*.h) a condition so that each file is parsed only once.
  Some compilers give errors otherwise.

- Renamed structure hashtable to hashstruct. This because some compilers give errors
  because this name is already used in one of its header files.

- lookup of matrix elements is now considerably faster thanks to a binary search
  algorithm. This affects set_matrix(), get_mat_raw(), get_mat()
  Especially for larger problems the effect should be considerable.

- Following routines now return an integer value instead of void to indicate if they
  succeeded or not. return value FALSE is failure and TRUE is success:
  del_constraint(), del_column(), set_upbo(), set_lowbo(), set_bounds(),
  set_uprange(), set_lowrange(), set_int(), set_semicont(), set_rh(), set_rh_range(),
  set_constr_type(), get_row(), get_column(), mult_column(), get_reduced_costs()

- Following new routines are added to allow to access data without having to access
  the lprec structure. This makes it less release dependent and sertainly less
  language dependent. It is advised to use these routine as much as possible and
  only to read/write in the lprec structure when nothing else is possible:
  set_verbose(), get_verbose(), set_timeout(), put_abortfunc(), put_logfunc(),
  put_msgfunc(), set_print_duals, is_print_duals(), set_print_sol(), is_print_sol(),
  set_debug(), is_debug(), set_print_at_invert(), is_print_at_invert(), set_trace(),
  is_trace(), set_anti_degen(), is_anti_degen(), set_do_presolve(), is_do_presolve(),
  set_max_num_inv(), get_max_num_inv(), set_bb_rule(), get_bb_rule(), set_obj_bound(),
  get_obj_bound(), set_floor_first(), get_floor_first(), set_infinite(),
  get_infinite(), set_epsilon(), get_epsilon(), set_epsb(), get_epsb(), set_epsd(),
  get_epsd(), set_epsel(), get_epsel(), set_scalemode(), get_scalemode(),
  set_improve(), is_improve(), set_lag_trace(), is_lag_trace(), set_piv_rule(),
  get_piv_rule(), set_break_at_first(), is_break_at_first(), set_bb_floorfirst(),
  is_bb_floorfirst(), set_break_at_value(), get_break_at_value(), set_negrange(),
  get_negrange(), set_epsperturb(), get_epsperturb(), set_epspivot(), get_epspivot(),
  get_max_level(), get_total_nodes(), get_total_iter(), get_objective(), get_Nrows(),
  get_Ncolumns(), get_variables(), get_ptr_variables(), get_constraints(),
  get_ptr_constraints(), get_sensitivity_rhs(), get_ptr_sensitivity_rhs(),
  get_sensitivity_obj(), get_ptr_sensitivity_obj()
  Note that routines get_variables(), get_constraints(), get_sensitivity_rhs(),
  get_sensitivity_obj() return with a copy of the values and that the provided
  variable arrays must already be allocated. These routines are especially ment
  to be called from other languages via a dll. When the library is called from
  C, then the get_ptr_ routines will be preferred by most users since they don't
  need extra memory. They just return a pointer.

- With the routines set_timeout(), get_timeout() it is possible to set a timeout
  in seconds. This makes it possible to interrupt a calculation after a specific
  time.

- With the routine put_abortfunc it is possible to set a abort routine. This routine
  will be called frequently. The user can add any logic he wants in this routine
  and its returnvalue determines if the process should be aborted or not. The normal
  returnvalue of this routine must be 0 and to abort <> 0.

- set_upbo(), set_lowbo(), set_bounds(), set_uprange(), set_lowrange() no longer
  complain about setting bounds smaller than the lower bound or larger than the upper
  bound. The values are just accepted. However when the model is optimized, the
  isvalid() routine is called and there the bounds are checked. If there is a lower
  bound larger than its upper bound then this is reported there and the model is not
  optimized.
  Another change is that the routines also accept and apply bounds which are less
  restrictive then previous set bounds. Previously these new bounds were ignored.
  Ifthe old behaviour is still needed then the caller must check this.
  This change allows to temporary set incorrect bounds.

- lp_solve.1 is updated.

- Changed demo.c and lp_solve.c to use new routines on places where lpstruct
  structure was accessed. This makes them less release dependent.

- When compiled as a windows DLL, following routines are now also available:
  set_verbose(), get_verbose(), set_timeout(), get_timeout(), set_print_duals(),
  is_print_duals(), set_print_sol(), is_print_sol(), set_debug(), is_debug(),
  set_print_at_invert(), is_print_at_invert(), set_trace(), is_trace(),
  set_anti_degen(), is_anti_degen(), set_do_presolve(), is_do_presolve(),
  set_bb_rule(), get_bb_rule(), set_obj_bound(), get_obj_bound(), set_floor_first(),
  get_floor_first(), set_infinite(), get_infinite(), set_epsilon(), get_epsilon(),
  set_epsb(), get_epsb(), set_epsd(), get_epsd(), set_epsel(), get_epsel(),
  set_scalemode(), get_scalemode(), set_improve(), is_improve(), set_lag_trace(),
  is_lag_trace(), set_piv_rule(), get_piv_rule(), set_break_at_first(),
  is_break_at_first(), set_bb_floorfirst(), is_bb_floorfirst(), set_break_at_value(),
  get_break_at_value(), set_negrange(), get_negrange(), set_epsperturb(),
  get_epsperturb(), set_epspivot(), get_epspivot(), get_max_level(),
  get_total_nodes(), get_total_iter(), get_objective(), get_variables(),
  get_constraints(), get_Nrows(), get_Ncolumns(), put_abortfunc(), put_logfunc(),
  put_msgfunc()
